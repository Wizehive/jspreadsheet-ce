<script type="text/javascript" src="index.js"></script>
<link rel="stylesheet" href="jspreadsheet.css" type="text/css" />

<script src="https://jsuites.net/v4/jsuites.js"></script>
<link
  rel="stylesheet"
  href="https://jsuites.net/v4/jsuites.css"
  type="text/css"
/>
<link
  rel="stylesheet"
  href="https://fonts.googleapis.com/css?family=Material+Icons"
/>

<link
  rel="stylesheet"
  type="text/css"
  href="http://weareoutman.github.io/clockpicker/dist/jquery-clockpicker.min.css"
/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script src="http://weareoutman.github.io/clockpicker/dist/jquery-clockpicker.min.js"></script>

<div id="spreadsheet" style="margin-left: 20%"></div>
<button onclick="getReadOnlyCellss()">Click Me</button>

<script>
  var data2 = [
    ["PHP", "14:00", "PHP", "14:00"],
    ["Javascript", "16:30", "PHP", "14:00"],
    ["Javascript", "16:30", "PHP", "14:00"],
  ];
  var styleObj = {};

  var customColumn = {
    // Methods
    closeEditor: function (cell, save) {
      var value = cell.children[0].value;
      cell.innerHTML = value;
      return value;
    },
    openEditor: function (cell) {
      // Create input
      var element = document.createElement("input");
      element.value = cell.innerHTML;
      // Update cell
      cell.classList.add("editor");
      cell.innerHTML = "";
      cell.appendChild(element);
      $(element).clockpicker({
        afterHide: function () {
          setTimeout(function () {
            // To avoid double call
            if (cell.children[0]) {
              myTable.closeEditor(cell, true);
            }
          });
        },
      });
      // Focus on the element
      element.focus();
    },
    getValue: function (cell) {
      console.log("cell", cell);
      return cell.innerHTML;
    },
    setValue: function (cell, value) {
      cell.innerHTML = value;
    },
  };

  myTable = jspreadsheet(document.getElementById("spreadsheet"), {
    data: data2,
    minDimensions: [10, 100],
    tableOverflow: true,
    tableWidth: "1000px",
    freezeColumns: 2,
    columns: [
      { type: "text", title: "Course Title", width: 300 },
      { type: "text", title: "Time", width: 100, editor: customColumn },
      { type: "text", title: "Course Title", width: 300 },
      { type: "text", title: "Course Title", width: 300 },
      { type: "text", title: "Course Title", width: 300 },
    ],
    toolbar: [
      {
        type: "i",
        content: "undo",
        onclick: function () {
          myTable.undo();
        },
      },
      {
        type: "i",
        content: "redo",
        onclick: function () {
          myTable.redo();
        },
      },
      {
        type: "divisor",
      },
      {
        type: "i",
        content: "lock",
        tooltip: "Editable",
        showtext: "Editable",
        onclick: function () {
          const [first, second] = myTable.selectedCell;
          let readOnlyFlag = false;
          if (!myTable.isReadOnly([first, second])) {
            readOnlyFlag = !readOnlyFlag;
          }
          myTable.setReadOnly([0, 1], true);
        },
      },
      {
        type: "i",
        content: "ac_unit",
        tooltip: "freeze",
        showtext: "Freeze",
        disable: true,
        onclick: function () {
          console.log(myTable.getSelectedColumns());
        },
      },
      {
        type: "select",
        tooltip: "data-type",
        disable: true,
        k: "data-type",
        v: ["Text", "Number", "Date"], // Custom data type options
      },
      {
        type: "divisor",
      },
      {
        type: "select",
        k: "font-family",
        v: ["Arial", "Verdana"],
      },
      {
        type: "select",
        k: "font-size",
        v: [
          "9px",
          "10px",
          "11px",
          "12px",
          "13px",
          "14px",
          "15px",
          "16px",
          "17px",
          "18px",
          "19px",
          "20px",
        ],
      },
      {
        type: "divisor",
      },
      {
        type: "i",
        content: "format_bold",
        k: "font-weight",
        v: "bold",
      },
      {
        type: "i",
        content: "format_italic",
        k: "font-style",
        v: "italic",
      },
      {
        type: "i",
        content: "format_underline",
        k: "text-decoration",
        v: "underline",
      },
      {
        type: "i",
        content: "strikethrough_s",
        k: "text-decoration",
        v: "line-through",
      },
      {
        type: "divisor",
      },
      {
        type: "color",
        content: "format_color_text",
        k: "color",
      },
      {
        type: "color",
        content: "format_color_fill",
        k: "background-color",
      },
      {
        type: "divisor",
      },
      {
        type: "i",
        content: "format_align_left",
        k: "text-align",
        v: "left",
      },
      {
        type: "i",
        content: "format_align_center",
        k: "text-align",
        v: "center",
      },
      {
        type: "i",
        content: "format_align_right",
        k: "text-align",
        v: "right",
      },
      {
        type: "i",
        content: "format_align_justify",
        k: "text-align",
        v: "justify",
      },
    ],
    onselection: function (
      el,
      borderLeft,
      borderTop,
      borderRight,
      borderBottom
    ) {
      var columnStart = borderLeft;
      var columnEnd = borderRight;
      var rowStart = borderTop;
      var rowEnd = borderBottom;
      if (columnStart === columnEnd && rowStart === rowEnd) {
        // Single cell selected
        var columnName = String.fromCharCode(65 + columnStart);
        var cellAddress = columnName + (rowStart + 1);
        var cellValue = myTable.getValue(cellAddress, true);
        myTable.setCellIndication(cellAddress);
        myTable.setCellValue(cellValue);
      } else if (rowStart === rowEnd) {
        // Entire column selected
        var columnNameStart =
          String.fromCharCode(65 + columnStart) + (rowStart + 1);
        var columnNameEnd =
          String.fromCharCode(65 + columnEnd) + (rowStart + 1);
        var columnRangeAddress = columnNameStart + ":" + columnNameEnd;
        myTable.setCellIndication(columnRangeAddress);
      } else if (rowStart === 0 && rowEnd === 0 && columnStart !== columnEnd) {
        // Range of columns selected
        var columnNameStart =
          String.fromCharCode(65 + columnStart) + (rowStart + 1);
        var columnNameEnd = String.fromCharCode(65 + columnEnd) + (rowEnd + 1);
        var columnRangeAddress = columnNameStart + ":" + columnNameEnd;
        myTable.setCellIndication(columnRangeAddress);
      } else {
        // Multiple cells selected
        var selectedCells = [];

        // Iterate over the selected columns
        for (var col = columnStart; col <= columnEnd; col++) {
          var columnName = String.fromCharCode(65 + col);
          selectedCells.push(
            columnName + (rowStart + 1) + ":" + columnName + (rowEnd + 1)
          );
        }
        myTable.setCellIndication(selectedCells.join(", "));
      }
    },
    allowManualInsertRow: false,
    allowInsertRow: false,
    allowManualInsertColumn: false,
    disableToolbar: false,
    disableContextMenu: true,
    oneditionstart: (e, td) => {
      console.log("Edition Start", td);
      if (td.innerHTML) {
        if (td.innerHTML.charAt(0) === "=") {
          styleObj = {};
          const val = td.innerHTML.toUpperCase();
          const cellPattern = /[A-Z]+\d+/g; // Regular expression to match cell
          const cellReferences = val.match(cellPattern);
          cellReferences?.forEach((cell, index) => {
            styleObj[cell] = getStyleForCell(index);
          });
          myTable.setStyle(styleObj);
        }
      }
      td.addEventListener("input", (event) => {
        if (
          event.inputType === "deleteContentBackward" ||
          event.inputType === "deleteContentForward"
        ) {
          let newStyleObj = {};
          Object.keys(styleObj).forEach(
            (key) => (newStyleObj[key] = "border:;")
          );
          myTable.setStyle(newStyleObj);
        }
        const value = event.target.value;
        if (event.key == "=" || value.charAt(0) === "=") {
          styleObj = {};
          const val = value.toUpperCase();
          const cellPattern = /[A-Z]+\d+/g; // Regular expression to match cell
          const cellReferences = val.match(cellPattern);
          cellReferences?.forEach((cell, index) => {
            styleObj[cell] = getStyleForCell(index);
          });
          myTable.setStyle(styleObj);
        }
      });
    },
    oneditionend: (e, td) => {
      let newStyleObj = {};
      Object.keys(styleObj).forEach((key) => (newStyleObj[key] = "border:;"));
      myTable.setStyle(newStyleObj);
      styleObj = {};
    },
    oncolumnselection: (e, cid) => {
      myTable.enableToolbarItem();
      console.log("On Column Selection", e, cid);
    },
    onbodyselection: (e, rid) => {
      myTable.disableToolbarItem();
      console.log("On Body Selection", e, rid);
    },
    onrowselection: (e, rid) => {
      // myTable.disableToolbarItem();
      console.log("On Row Selection", e, rid);
    }
  });
  const getStyleForCell = function (index) {
    const colors = ["#0C866D", "#F0AD4E", "#9747FF", "#4DA6C8", "#FF8B94"];
    return `border: 2px dashed ${colors[index % colors.length]};`;
  };

  const getReadOnlyCellss = () => {
    console.log("Read Only Cells");
    console.log(myTable.getReadOnlyCells());
  };
</script>
